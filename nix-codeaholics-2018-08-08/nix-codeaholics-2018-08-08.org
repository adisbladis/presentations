#+TITLE:     Nix - Zero to full cloud deployment in 30 minutes
#+AUTHOR:    Adam Hose
#+EMAIL:     adisbladis@gmail.com
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:https://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+startup: beamer
#+LaTeX_CLASS: beamer

* Introduction
** Who am I?
*** Who am I?
- Likes programming in Nix, Python, Go, Rust, Lisp
- Loves UNIX
- I'm a seÃ±or developer at Enuma Technologies
- First used Nix back in 2015
- NixOS member since 2017

** Nix - what is it?
*** Nix - what is it?
- A package manager
- A build system
- A language

** Package management
*** What do we expect from package managers?
- Manages software builds
  - Build manifests
- Manages package repositories
  - Debian: universe/multiverse/non-free
  - Npm: Registry
- Create redistributable packages
- Dependency management
- Upgrades/downgrades

*** Problems with traditional package management
- Underspecified dependencies
  - E.g. Program =x= _actually_ depends on =y= but not in the manifest
- Rolling back?
  - No atomicity
- Major upgrades
  - Often breaks entirely
  - Broken ABIs
- Packages are either installed or uninstalled
  - Need another package? You need to alter system state.
- Docker as a development environment
  - Need another tool in your Docker container? Time for a break...
- Ultimate trust
  - =nix-build --check=

*** How nix deals with these issues
- No unspecified dependencies
  - Dependency not in inputs? Not available at build time.
- Immutable package store
  - No more in-place upgrades
- Atomic installs/uninstalls/upgrades/downgrades
  - Using symlinks
- Pure package builds
*** Nixpkgs - The packages
- Available on Github
  https://github.com/nixos/nixpkgs
- Huge package tree
More packages than Debian/Ubuntu/Arch
- Very up to date
Packages are ~85% up to date
- Mostly free software
- Accepts unfree packages (but must be user enabled)
- Pull request based workflow on Github
  - Around 200-300 monthly contributors
  - Last week we saw ~600 commits from 140 authors
- Some fully autogenerated ecosystems
  - Emacs
  - Haskell
  - NodeJS
- Comes with lots of abstractions
  - Language specific
  - Source fetchers
  - Library functionality

* Nix

** Nix - An introduction

*** Nix - An introduction
- Reproducible deterministic builds
  - Easier to debug
  - No more "works on my machine"
- Packages built in isolation (sandboxed)
  - Only specified inputs are available
- All inputs are hashed
  - If any input changes it is considered to be a distinct evaluation
- All outputs are stored by hash
=/nix/store/<hash>-packagename-version/=
- Source based with binary cache
- Unprivileged installs
- Both Linux ( =x86_64= / =aarch64= ) and =OSX= are fully supported

** Nix - the language

*** Nix - the language
- Purely functional
  - Always returns the same answer given the same inputs
  - Evaluation has no side effects
- Lazy eval - Like haskell!
  - A good fit for package trees where you want to go from a few leafs (user installed packages) to many dependencies
- Untyped - With a few exceptions
  - paths, urls, bool, int, lists, functions and attrsets

*** Nix - the language
- Hello world
#+begin_src nix
let
  name = "Codeaholics";
"Hello ${name}"
#+end_src

- Functions
#+begin_src nix
let
  fn = (a: b: a + b);
in fn 5 5
#+end_src

- Expressions
#+begin_src nix
let
  x = if x > 5 then x else throw "x is too small";
in x 5
#+end_src

*** Nix - the language
- Attribue sets (maps)
#+begin_src nix
{
  foo="bar";
}
#+end_src

- Lists
#+begin_src nix
[ "foo" "bar" ]
#+end_src

- Currying (partial application)
#+begin_src nix
let
  fn = (a: b: a * b);
  mul5 = fn 5;
in mul5 5;
#+end_src

*** Nix - The build system
- Clear separation between build time and runtime
  - No need for complicated multi-stage builds
- Each package is composed of a =derivation=
  - A derivation is the package description
  - Lists all input =derivations= (packages)
  - A =derivation= can depend on one or more =outputs=
- One build results in one or more =outputs=
  - =dev=
  - =man=
  - =bin=

*** Nix - The build process

=/nix/store/= *2i4vyzq4i9j7l8d2g3fdal97h4mi5sy3-openssh* =-7.7p1/=
- The OpenSSH derivation + _all_ of it's input are instantiated
- A hash is calculated over the instantiated derivation
- A nix build environment (sandbox) is created for the package
- Each build =phase= from the derivation runs.
  =unpackPhase=, =patchPhase=, =buildPhase=, =installPhase=, etc
- All binaries are patched
  - Shared libraries point to absolute store path
  - Shebangs are patched
- Package is being written to the nix store

*** Nix - installing packages
- Install a package into your user profile
#+begin_src shell
nix-env -iA nixpkgs.hello
#+end_src

- Global package installs
#+begin_src nix
# /etc/nixos/configuration.nix
environment.systemPackages = [
  pkgs.hello
];
#+end_src

*** Nix - magical superpowers
- Start a new shell with a package
#+begin_src shell
nix-shell -p hello
#+end_src

- Magical superpowers
#+begin_src shell
nix-shell -p 'python3.withPackages(ps: with ps; [
  ipython tensorflow numpy requests
])' --run ipython
#+end_src

*** Nix - magical superpowers
- Self-documenting scripts
#+begin_src python
#!/usr/bin/env nix-shell
#! nix-shell -i python3 -p python3 python3Packages.requests
import requests

if __name__ == '__main__':
    print(requests.get('https://codeaholics.io/'))
#+end_src

*** Nix - magical superpowers
- Overrides are a breeze
#+begin_src nix
somePackage.overrideAttrs(oldAttrs: {
  name = "overriden-${oldAttrs.version}";

  buildInputs = oldAttrs.buildInputs ++ [ pkgs.firefox ];

  patches = [ (fetchpatch {
    url = "https://github.com/path/to.patch";
    sha256 = "1n1x1f7xgci7wqm0xjbxxlxxd1kq3866a3xnv7dfz2512z6051fw";
  }) ];
})
#+end_src

- Cross compilation at your finger tips

* Live demo
** Live demo

*** Live demo
- Goals
  - Making a declarative environment
  - Pinning nixpkgs
  - Writing our project
  - Writing a derivation
     Add missing inputs
  - Build a Docker container

- Tooling
  - direnv

*** Demo time!
- Live coding a service

* NixOS
** NixOS
*** NixOS - Fully declarative operating system
- A module system built on top of Nix
- Fully declarative service management
- Atomic upgrades and rollbacks
- Composable reusable systems

*** NixOS - An example configuration
#+begin_src nix
{ config, pkgs, ... }:

{
  imports = [ ./hardware-configuration.nix ];

  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  services.redis.enable = true;
  services.redis.port = 9001;

  users.extraUsers.adisbladis = {
    uid = 1000;
    isNormalUser = true;
    extraGroups = [ "wheel" ];
  };
}
#+end_src

* NixOps
*** Nixops
- Fully declarative cloud deployment tool
- Deploys to AWS/Azure/GCP/hetzner/bare-metal
- Replaces ansible/salt/puppet/chef

*** Nixops - deploying a service
- Example config
#+begin_src nix
{ timeserver =
    { resources, ... }:
    {
      deployment.targetEnv = "ec2";
      deployment.ec2.region = "us-west-2";
      deployment.ec2.instanceType = "t2.small";
      deployment.ec2.keyPair = "my-aws-keypair";

      systemd.services.geth = {
        description = "Time as a service";
        serviceConfig.Type = "simple";
        serviceConfig.Restart = "on-failure";
        serviceConfig.User = "nobody";
        wantedBy = [ "multi-user.target" ];
        after = [ "network.target" ];
      };};}
#+end_src


- Live demo part 2

* Closing words
*** Production users
- EU
  - 3 TOP 500 computers!
- Intel
- Target
- Pinterest
- Zalora
- Packet.net

*** Takeaways
- Understand how and why Nix isolation works
- Have a rough idea of the Nix ecosystem
- Know how to start using Nix
- Enlightenment - hopefully

*** Questions?
[[../nixos.png]]
